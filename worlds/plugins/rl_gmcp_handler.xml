<?xml version="1.0" encoding="iso8859-15"?>
<!DOCTYPE muclient>
<!-- Saved on domingo, febrero 28, 2016, 2:56 p.m. -->
<!-- MuClient version 4.84 -->

<!-- Plugin "rl_gmcp_handler" generated by Plugin Wizard -->

<muclient>
<plugin
   name="rl_gmcp_handler"
   author="Francisco R. Del Roio"
   id="3b764c2d9d7e85dbf01ddfab"
   language="Lua"
   purpose="Controlador GMCP para Reinos de leyenda"
   date_written="2018-01-22 09:34:00"
   requires="4.84"
   version="1.1"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<aliases>
  <alias
   script="DebugGMCP"
   match="^gmcpdebug ([012]{1,1})$"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   script="SendGMCP"
   match="^gmcpsend (.*?)$"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
</aliases>


<script>
<![CDATA[
require "ppi"

-- Algunas constantes
local IAC, SB, SE, DO = 0xFF, 0xFA, 0xF0, 0xFD
local GMCP      = 201

-- Datos del plugin
local callbacks = {}

local function Send_GMCP_Packet (what)
	assert (what, "Send_GMCP_Packet recibió un valor nil.")

	SendPkt (string.char (IAC, SB, GMCP) .. 
				(string.gsub (what, "\255", "\255\255")) ..  -- IAC becomes IAC IAC
				string.char (IAC, SE))
end -- Send_GMCP_Packet

local function Notify_GMCP_Message(message, data)
	assert(message, "No se recibió un mensaje.")
	assert(data, "No hay datos para entregar junto con el mensaje.")

	-- Salimos si no hay callbacks
	if not callbacks[message] then return end

	-- Recorremos la lista para enviar las llamadas
	for k, v in pairs(callbacks[message]) do
		local rs, a, b = CallPlugin(v.plugin, v.funcname, message, data)
	end -- callbacks
end -- function

-- Depuración
local GMCPDebug = 0

function DebugGMCP(name, line, wildcards)
	newval = tonumber(wildcards[1])
	if not newval or newval > 2 or newval < 0 then
		ColourNote("darkorange", "", "GMCPDebug valid values are: 0 - off, 1 - simple, 2 - verbose")
		return
	end
	GMCPDebug = newval
	local msg = "off"
	if GMCPDebug == 1 then
		msg = "simple"
	elseif GMCPDebug == 2 then
		msg = "verbose"
	end
	ColourNote ("darkorange", "", "GMCPDebug: " .. msg)
end

function SendGMCP(name, line, wildcards)
	if (wildcards[1] ~= nil) then
		Send_GMCP_Packet(wildcards[1]) -- in gmcphelper
	end
end 

---------------------------------------------------------------------------------------------------
-- Callbacks definidas por MUSHClient
---------------------------------------------------------------------------------------------------

function OnPluginTelnetSubnegotiation (msg_type, data)
	if msg_type ~= GMCP then
		return
	end -- if not GMCP

	if GMCPDebug > 0 then
		AppendToNotepad("GMCP Debug", data.."\r\n")
	end

	message, params = string.match (data, "([%a.]+)%s+(.*)")

	if not message then
		return
	end -- if

	-- Este mensaje no lo podemos usar en mushclient así que lo omitimos definitivamente
	if message == "Client.GUI" then return end

	-- Llamamos los callbacks ...
	Notify_GMCP_Message(message, params)
	return
end -- function OnPluginTelnetSubnegotiation

function OnPluginInstall()
	BroadcastPlugin(1,"reload") -- reload basically tells other plugins "clear all your gmcp data"
end

function OnPluginTelnetRequest (msg_type, data)
	if msg_type == GMCP and data == "WILL" then
		return true
	end -- if

	if msg_type == GMCP and data == "SENT_DO" then
		-- This hard-coded block may need to be made into a config table as we add more message types.
		Send_GMCP_Packet (string.format ('Core.Hello { "client": "MUSHclient", "version": "%s" }', Version ()))
		Send_GMCP_Packet ('Core.Supports.Set [ "Char 1", "Comm 1", "Room 1", "Core 1", "Mapa 1" ]')
		return true
	end -- if GMCP login needed (just sent DO)

	return false
end -- function OnPluginTelnetRequest

function add_callback(message, plugin_id, func)
	-- Comprobamos primero que nada los datos
	assert(message, "No se proveyó un mensaje.")
	assert(type(message) == "string", "El único tipo válido para los mensajes son las cadenas de texto.")
	assert(plugin_id, "No se indicó un plugin.")
	assert(type(plugin_id) == "string", "El ID es una cadena de 16 caracteres.")
	assert(func, "No se indico un callback.")
	assert(type(func) == "string", "Se debe pasar el nombre de la función, nó una función compilada.")

	-- Sencillamente añadimos el callback a la lista.
	callbacks[message] = callbacks[message] or {}
	
	-- Da algunos problemas si el mismo plugin agrega la misma función varias veces
	for k, v in pairs(callbacks[message]) do
		if v.plugin == plugin_id and v.funcname == func then
			return -- Salimos
		end -- if
	end -- callbacks
	
	table.insert(callbacks[message], {
		plugin = plugin_id,
		funcname = func
	})
end -- function
ppi.Expose "add_callback"

function remove_callback(message, plugin_id, func)
	-- Comprobamos primero que nada los datos
	assert(message, "No se proveyó un mensaje.")
	assert(type(message) == "string", "El único tipo válido para los mensajes son las cadenas de texto.")
	assert(plugin_id, "No se indicó un plugin.")
	assert(type(plugin_id) == "string", "El ID es una cadena de 16 caracteres.")
	assert(func, "No se indico un callback.")
	assert(type(func) == "string", "Se debe pasar el nombre de la función, nó una función compilada.")

	-- Eliminamos la posibilidad de que no hayan callbacks registrados.
	assert(callbacks[message], "Este mensaje no tiene ningún callback.")

	for k, v in pairs(callbacks[message]) do
		if v.plugin == plugin_id and v.funcname == func then
			return table.remove(callbacks[message], k)
		end -- callbacks
	end -- callbacks
end -- function
ppi.Expose "remove_callback"

]]>
</script>


</muclient>
