<?xml version="1.0" encoding="iso8859-15"?>
<!DOCTYPE muclient [
  <!ENTITY prefijo "(?:(?:.*?)(?:\&gt; |\] |\} )|)" >
  <!ENTITY intens "(?:(con |)(débilmente |poca fuerza |fuerza |mucha fuerza |violentamente |fuerza sobrehumana |fuerza divina |increíble potencia |cólera titánica |))" >
  ]>
<!-- Saved on domingo, mayo 07, 2017, 5:49 p.m. -->
<!-- MuClient version 4.94 -->

<!-- Plugin "rl_mapper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="rl_mapper"
   author="Francisco R. Del Roio"
   id="e634c782be2e150ffc27eded"
   language="Lua"
   purpose="Un mapeador para reinos de leyenda que funciona con mushclient."
   date_written="2017-05-07 17:47:06"
   requires="4.94"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[
	Mapa de Reinos de leyenda
	
	Este plugin añade el soporte para un mapa de reinos de leyenda MUD.
	
	Estos son los comandos disponibles por ahora:
	
	General:
	- mapa ayuda 				 - Este mensaje de ayuda
	- mapa mostrar  			 - Muestra la vista gráfica del mapa.
	- mapa ocultar 			 - Oculta la vista gráfica del mapa.
	
	Búsqueda y navegación:
	- mapa navegar <texto> 	 - Realiza una búsqueda de texto completo entre las salas cercanas y ofrece una lista si hay muchas posibilidades. En caso de existir solo una, comenzará a navegar hasta ella automáticamente.
	- mapa buscar <texto> 	 - Realiza una búsqueda de texto completo entre todas las salas del MUD y la que se seleccione será marcada como la sala actual.
	
	Base de Datos:
	- mapa importar 				 - Importa el mapa desde una base de datos (solo soporta mapas de ZMud).
	- mapa editar 						 - Alterna el modo de edición.
	- mapa conectar <id> <hacia> <desde> - Conecta la sala actual con la próxima bidireccionalmente.
	- mapa cambiar <id> <nombre> 		 - Renombra una salida.
	
	Este plugin tiene unas cuantas carencias:
	
	1. El plugin se apoya totalmente en el módulo llamado "mapper.lua" incluido con MUSHClient, por lo que todos los mensajes relacionados directamente con el mapper están en inglés y su interfaz es poco intuitiva para usuarios de lectores de pantalla.
	2. Como se dijo arriba, por ahora solo se soportan mapas de ZMud, pero se espera poder añadir soporte para mapas de CMud y Mudlet (incluso de tintin) en el futuro.
]]>
</description>

</plugin>


<!--  Triggers  -->










<triggers>
  <trigger
   enabled="y"
   match="^&prefijo;Cola de comandos borrada \(\'peleas parar\' detendrá los ataques si es lo que querías\)\.$"
   regexp="y"
   sequence="100"
   script="on_stop"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   group="General"
   lines_to_match="2"
   match="^&prefijo;(?P&lt;room_name&gt;.*?)\n\s\[(?P&lt;exits&gt;[a-z\|\-\~\*\,]*)\] \((?P&lt;branches&gt;[a-z\|\-\~\*\,]*)\)$"
   multi_line="y"
   regexp="y"
   script="on_mirar"
   sequence="100"
   enabled="y"
   name="mirar_arbol"
  >
  </trigger>
  <trigger
   enabled="y"
   group="General"
   match="^&prefijo;(?P&lt;room_name&gt;.*?) \[(?P&lt;exits&gt;[a-z\|\-\~\*\,]*)\](?:\[.*\] |)$"
   name="mirar"
   regexp="y"
   script="on_mirar"
   sequence="100"
   lowercase_wildcard="y"
  >
  </trigger>
  
  <trigger
   match="LPmud version: *."
   enabled="y"
   sequence="100"
   send_to="12"
  >
	<send>
	  EnableTrigger("mirar", false)
	  EnableTrigger("mirar_arbol", false)
	</send>
  </trigger>

  <trigger
   match="^(?:\s+)Los Dioses te dan la bienvenida a sus Reinos de Leyenda, (\w+)\.(?:\s+)$"
   enabled="y"
   regexp="y"
   send_to="12"
   sequence="100"
  >
	<send>
	  EnableTrigger("mirar", true)
	  EnableTrigger("mirar_arbol", true)
	</send>
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   script="on_ver"
   match="mapa ver"
   enabled="y"
   sequence="100"
   group="debug"
  >
  </alias>


  <alias
   script="on_limpiar"
   match="mapa olvidar"
   enabled="y"
   sequence="100"
  >
  </alias>
  
  <alias
   script="on_pedir"
   match="q *"
   enabled="y"
   group="Debug"
   sequence="100"
  >
  </alias>

  <alias
   script="on_importar"
   match="mapa importar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_buscar"
   match="mapa buscar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_ir"
   match="mapa navegar *"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_mostrar"
   match="mapa mostrar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_ocultar"
   match="mapa ocultar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   match="mapa editar"
   script="on_editar"
   sequence="100"
   enabled="y"
  >
  </alias>
  
  <alias
   match="^mapa setsala (?P&lt;id&gt;\d*?)$"
   script="on_posicionar"
   regexp="y"
   enabled="y"
   sequence="100">
  </alias>

  <alias
   match="^mapa conectar (?P&lt;id&gt;\d*?) (?P&lt;hacia&gt;\w*?) (?P&lt;desde&gt;\w*?)$"
   regexp="y"
   sequence="100"
   script="on_conectar"
   enabled="y"
  >
  </alias>

  <alias
   match="^mapa cambiar (?P&lt;id&gt;\d*?) (?P&lt;hacia&gt;\w*?)$"
   regexp="y"
   sequence="100"
   script="on_cambiar"
   enabled="y"
  >
  </alias>
</aliases>





<!--  Script  -->
<script>
<![CDATA[
require "rl_stuff"
require "mapper"
require "copytable"
require "serialize"
require "var"
require "ppi"

-- La base de datos
local db = nil
local db_name = GetInfo(67).."mapa_rl.sqlite"

-- Las salas ya cargadas y cacheadas
local rooms = {}

-- La config (exigida por el módulo del mapper)
local config = {}

-- Posición actual en el mapa e historial de posiciones.
local current = {}

-- Para mirar la sala
local salidas

-- Datos para el modo edición
local editar = {
	dirs = {},
	slugs = {},
}

-- Datos variados
local data = {}

-- Un mapeo de salidas para poder saber cuales son válidas
local mapa_salidas = {
	n = "n",
	norte = "n",
	north = "n",
	ne = "ne",
	noreste = "ne",
	e = "e",
	este = "e",
	east = "e",
	sudeste = "se",
	se = "se",
	s = "s",
	sur = "s",
	south = "s",
	so = "sw",
	sw = "sw",
	sudoeste = "sw",
	o = "w",
	oeste = "w",
	west = "w",
	w = "w",
	no = "nw",
	noroeste = "nw",
	nw = "nw",
	ar = "up",
	arriba = "up",
	up = "up",
	ab = "down",
	abajo = "down",
	down = "down",
	fuera = "fu",
	dentro = "de",
	puerta = "pu"
}

-- Para obtener la salida inversa en el modo de edición
local salidas_inversas = {
	e = "w",
	w = "e",
	s = "n",
	n = "s",
	se = "nw",
	nw = "se",
	ne = "sw",
	sw = "ne",
	up = "down",
	down = "up",
}

-- Esta tabla contiene nombres largos para las salidas. Usado sobre todo para mostrar correctamente los nombres dentro del plugin
local salidas_localizadas = {
	e = "este",
	w = "oeste",
	n = "norte",
	s = "sur",
	nw = "noroeste",
	ne = "noreste",
	sw = "suroeste",
	se = "sudeste",
	up = "arriba",
	down = "abajo",
	fu = "fuera",
	de = "dentro",
}

local enviar = {
	w = "o",
	sw = "so",
	nw = "no",
	up = "ar",
	down = "ab",
	n = "n",
	s = "s",
	e = "e",
}

-- Tomado y adaptado de www.gammon.com/db
local function query(qs, valores)
	qs = utf8convert(qs)
	-- Lo primero es preparar la consulta
	local stmt, success, err_message = db:prepare (qs)
	
	-- Comprobamos que haya devuelto algo, sino es error.
	assert(stmt, db:errmsg())
	
	-- asignar los valores de la tabla
	if valores and type(valores) == "table" then
		stmt:bind_names(valores)
	end -- tables
	
	local filas = {}
	for fila in stmt:nrows() do
		table.insert(filas, fila)
	end -- nrows
	
	local errcode = stmt:finalize()
	assert(errcode == 0, "Ocurrió un error al ejecutar la consulta. Error "..errcode..".")
	return filas
end -- query

local function elegir_sala(uids)
	local lista = {}
	local cuenta = 0

	-- Simplificamos todo retornando el primer valor si hay solamente uno ...
	if #uids == 1 then
		return tonumber(uids[1])
	end -- uids

	for k, v in pairs(uids) do
		local sala = getRoom(v)

		local item = string.format("%s\nSalidas:\n", sala.name)
		
		for i, j in pairs(sala.exits) do
			local otra_sala = getRoom(j)
			
			item = item..string.format("%s: %s\n", i, getRoom(j).name)
		end -- exits
		
		lista[sala.id] = utf8convert(item)
		cuenta = cuenta + 1
	end -- uids
	
	return utils.listbox("Selecciona una sala",
		string.format("Se encontraron %d salas en total. Elige una para seleccionarla.", cuenta),
		lista)
end -- function

function getRoom(uid)
	local room = rooms[uid]
	
	if not room then
		room = {}

		assert(type(uid) == "number", "El UID pasado no es válido.")

		if query("select count(*) as count from salas;")[1].count == 0 then
			mapper.mapprint("No hay salas cargadas. Considera importar un mapa")
		end -- query

		local success, result, error = pcall(query,[[
			select sala_id, nombre
			from salas
			where sala_id = :uid;
		]], {uid = uid})

		assert(success)

		room.id = result[1].sala_id
		room.name = utf8convert(result[1].nombre)
		room.exits = {}
		
		success, result = pcall(query,[[
			select * from salidas
			where desde_id = :uid;
		]], {uid = uid})

		for k, v in pairs(result) do
			room.exits[v.nombre] = v.hasta_id
		end -- for in result
		
		rooms[room.id] = room
	end -- room
	
	-- room = copytable.shallow(room)
	
	room.overmessage = room.name
	
	return room
end -- GetRoom

local function guardar_sala(sala)
	local result, result2
	assert(db:isopen())
	
	-- Si la sala tiene un ID, significa que ya está guardada en la base de datos
	if not sala.id then
		result = query([[
			insert into salas (nombre)
			values (:nombre);
		]], {nombre = sala.name})
		
		-- Como el motor no devuelve nada, tenemos que buscar por nosotros mismos el ID de la sala tras cargarla
		sala.id = db:last_insert_rowid()
		assert(sala.id and sala.id > 0, "Error al insertar la sala. ID no válido.")
		
		-- Ya que estamos guardando la sala por primera vez, no es necesario actualizar las salidas, simplemente insertarlas
		if sala.exits then
			for k, v in pairs(sala.exits) do
				result = query([[
					insert into salidas (desde_id, hasta_id, nombre)
					values (:desde_id, :hasta_id, :nombre);
				]], {desde_id = sala.id, hasta_id = v, nombre = k})

			end -- for sala.exits
		end -- sala.exits
		
	else
		-- Esto es para cambiar alguna información de la sala, como por ejemplo el nombre, la dirección de alguna salida, o el nombre de la dirección de alguna salida.
		
		-- Primero la sala en sí, que es la parte mas fácil
		result = query([[
			update salas set nombre = :nombre
			where sala_id = :sala_id;
		]], {sala_id = sala.id, nombre = sala.name})
		
		-- Sería bastante raro ver esto en una sala que se actualiza contra la base de datos, pero de todos modos lo ponemos
		if sala.exits then
			-- Este caso es un poco mas complicado

			-- primero que nada, tenemos que saber qué salidas están registradas en la base de datos
			local salidas_db = query([[
				select * from salidas
				where desde_id = :desde_id;
			]], {desde_id = sala.id})
			
			-- También necesitamos guardar en una lista las salidas que ya existen en la base de datos y que ya hemos procesado:
			local salidas_existentes = {}
			local salidas_cambiadas = {}
			
			-- en segundo lugar, tenemos que recorrer los resultados
			for k, v in pairs(salidas_db) do
				-- en este punto pueden darse varios casos posibles
				
				if not sala.exits[v.nombre] then -- aparentemente cambió el nombre de la salida
					salidas_cambiadas[v.hasta_id] = true
				elseif sala.exits[v.nombre] ~= v.hasta_id then -- cambia la sala a la que lleva esta salida
					result = query([[
						update salidas set hasta_id = :hasta_id
						where desde_id = :desde_id and hasta_id = :orig_hasta_id;
					]], {hasta_id = sala.exits[v.nombre], desde_id = v.desde_id, orig_hasta_id = v.hasta_id})
				end -- if
				
				-- recordamos la salida, para no tener que procesarla denuevo
				salidas_existentes[v.nombre] = true
			end -- salidas_db
			
			-- Luego de pasar por las de la db, pasamos por la de la sala cargada para guardarlas
			for k, v in pairs(sala.exits) do
				if salidas_cambiadas[v] then
					results = query([[
						update salidas set nombre = :nombre
						where desde_id = :desde_id and hasta_id = :hasta_id;
					]], {nombre = k, desde_id = sala.id, hasta_id = v})
				elseif not salidas_existentes[k] then
					result = query([[
						insert into salidas (desde_id, hasta_id, nombre)
						values (:desde_id, :hasta_id, :nombre);
					]], {desde_id = sala.id, hasta_id = v, nombre = k})
				end -- salidas_existentes
			end -- for sala.exits
		end -- sala.exits
	end -- sala.id
	
	return sala
end -- guardar_sala

local function salidaValida(salida, sala)
	local mi_sala

	assert(salida, "No se proporcionó una salida.")
	
	-- La sala tiene que ser de tipo number y la salida de tipo string
	assert(type(sala) == "number" or type(sala) == "nil", "La sala solo puede ser un número.")
	assert(type(salida) == "string", "La salida solo puede ser una cadena.")
	
	-- Lo primero es ver si hay una sala. En ese caso, obtenemos el objeto de sala correspondiente
	if sala then
		mi_sala = assert(getRoom(sala), "No se pudo encontrar ninguna sala con el ID proporcionado.")
	end -- if
	
	-- Si no hay una sala, solo podemos devolver con seguridad las direcciones cardinales básicas, en inglés.
	-- De todos modos, no sé por qué incluyo esto...
	if not mi_sala then
		return mapa_salidas[salida]
	end --if
	
	-- En caso de tener una sala válida, podemos devolver datos mas seguros.
	if mi_sala.exits[salida] then
		return salida
	elseif mi_sala.exits[mapa_salidas[salida]] then
		return mapa_salidas[salida]
	end -- if
end -- function

local function desdeSalida(sala, salida)
	assert(sala, "No se proporcionó una sala válida.")
	assert(salida, "No se proporcionó una salida.")
	
	-- La sala tiene que ser de tipo number y la salida de tipo string
	assert(type(sala) == "number", "La sala solo puede ser un número.")
	assert(type(salida) == "string", "La salida solo puede ser una cadena.")
	
	-- No es necesario ningún proceso complejo
	return assert(getRoom(sala).exits[salidaValida(salida, sala)], string.format("No se encuentra ninguna sala en dirección a %s.", salida))
end -- function

local function mover(sala)
	local dest_sala
	assert(sala, "No se proporcionó un Id de sala ni una dirección.")
	assert(type(sala) == "number" or type(sala) == "string", "La sala tiene que ser un Id numérico o una salida.")

	-- Lo primero es encontrar la sala por su ID, si el dato es numérico
	if type(sala) == "number" then
		dest_sala = assert(getRoom(sala), "La sala proporcionada no se pudo encontrar en la base de datos.")
	else
		local mi_sala

		-- En caso de que sea una string, sencillamente buscamos entre las salidas de la sala actual.

		-- Puede que no haya una sala actual, por lo que sencillamente salimos para evitarnos problemas
		if not current.room then
			return
		end -- if

		-- Evitamos errores
		local success, s_id = pcall(desdeSalida, current.room, sala)

		-- Si no hay éxito, significa que nos falta mapear una sala
		if not success then

			-- Si el modo de edición no está habilitado, salimos.
			if not var.editar then
				-- Limpiamos los datos, pues no hay salida mapeada ni estamos en modo de edición.
				current = {}
				mapper.hide()
				return
			end -- if
			
			-- Creamos una sala básica
			local sala_nueva = {
				name = data.nombre,
				exits = {}
			}
			
			local anterior = getRoom(current.room)

			-- Si la salida es estándar, sencillamente registramos la inversa
			if mapa_salidas[sala] then
				sala_nueva.exits[salidas_inversas[mapa_salidas[sala]]] = anterior.id
			end -- if

			db:exec("begin transaction;")
			
			-- Guardamos la sala nueva para poder obtener el ID
			local guardada = pcall(guardar_sala, sala_nueva)

			if not guardada then
				db:exec("rollback;")
				assert(guardada, db:errmsg())
			end

			-- Registramos la salida desde la sala anterior a esta.
			anterior.exits[mapa_salidas[sala] or sala] = sala_nueva.id

			-- guardamos la otra sala
			guardada = pcall(guardar_sala,anterior)

			if not guardada then 
				db:exec("rollback;")
				assert(guardada, db:errmsg())
			end
			
			db:exec("commit transaction;")
			
			mi_sala = sala_nueva
		else
			mi_sala = getRoom(s_id)
		end -- if
		
		dest_sala = mi_sala
	end -- if
	
	assert(dest_sala, "No se pudo encontrar ninguna sala válida. Sala: '${sala}'" % {sala=sala})
	
	-- Terminadas las comprobaciones, mostramos la sala en el mapa y la ponemos como current.room
	if current.prev and current.prev.room == dest_sala.id then
		current = current.prev
	else
		current = {
			room = dest_sala.id,
			last_dir = (function()
				if type(sala) == "string" then
					return sala
				end -- if
			end)(),
			prev = current
		}
	end -- if
	
	-- Posicionamos el mapa
	mapper.draw(dest_sala.id)
	
	-- Guardamos la sala en una variable externa, por si acaso
	var.sala = dest_sala.id
end -- mover

local function findRoomByName(name)
	local success, result, message = pcall(query,[[
		select sala_id from salas
		where nombre = :room_name;
	]], {room_name = name})
	
	assert(result, "Error: ${message}" % {message = message})
	
	return result
end -- findRoomByName

local function findRoomsWithNameContaining(pattern)
	local success, result, message = pcall(query,[[
		select sala_id from salas
		where nombre like '%' || :patron || '%';
	]], {patron = utils.utf8convert(pattern)})
	
	assert(success, "Error: ${result}" % {result = message})

	return result
end -- function

function OnGMCPInit()
	Send_GMCP_Packet('Core.Supports.add ["Room 1"]')
end -- function

function OnGMCP(mensaje)
	if mensaje ~= "Room.Movimiento" then return end
	play_sound("std/pasos_"..math.random(1,10)..".ogg")
	
	local dir = PedirGMCP("Room.Movimiento")[1]
	
	mover(dir)
	if not current.room then
		local rooms = findRoomsWithNameContaining(data.nombre)
		
		if #rooms == 1 then
			mover(rooms[1].sala_id)
			
			if not var.oculto then
				mapper.show()
			end -- oculto
		end -- if
	end -- current.room
end -- function

local function countRoomsWithNameContaining(name)
	local success, result = pcall(query, [[
		select count(*) as count from salas
		where nombre like '%' || :patron || '%';
	]], {patron = name})

	assert(success, "No se pudo contar el número de salas.")
	return result.count
end -- function

function OnPluginConnect()
	current = {}
end -- OnPluginConnect

function OnPluginDisconnect()
	current = {}
	var.sala = nil
	mapper.hide()
end -- OnPluginDisconnect

function OnPluginListChanged()
	RLStuffListChanged()
end -- function

function OnPluginInstall()
	db = sqlite3.open(db_name)
	local q = query("select * from sqlite_master where type = 'table' and name = 'salas';")
	
	if #q == 0 then
		local result = db:exec([[
			BEGIN TRANSACTION;

			-- Table: hash_salas
			CREATE TABLE hash_salas (
				slug    TEXT    NOT NULL,
				sala_id INTEGER NOT NULL
								DEFAULT 0
			);


			-- Table: salas
			CREATE TABLE salas (
				sala_id INTEGER PRIMARY KEY AUTOINCREMENT
								NOT NULL,
				nombre  TEXT    NOT NULL,
				zona_id INTEGER REFERENCES zonas (zona_id) ON DELETE SET NULL
			);


			-- Table: salas_importadas
			CREATE TABLE salas_importadas (
				importacion_id    INTEGER  PRIMARY KEY AUTOINCREMENT
										   NOT NULL,
				id_viejo          INTEGER  NOT NULL
										   DEFAULT 0,
				id_nuevo          INTEGER  NOT NULL
										   DEFAULT 0
										   REFERENCES salas (sala_id) ON DELETE CASCADE,
				fecha_importacion DATETIME NOT NULL
										   DEFAULT CURRENT_TIMESTAMP
			);


			-- Table: salidas
			CREATE TABLE salidas (
				salida_id       INTEGER PRIMARY KEY AUTOINCREMENT
										NOT NULL,
				desde_id        INTEGER NOT NULL
										REFERENCES salas (sala_id) ON DELETE CASCADE,
				hasta_id        INTEGER NOT NULL
										REFERENCES salas (sala_id) ON DELETE CASCADE,
				nombre          TEXT    NOT NULL,
				comando_antes   TEXT,
				comando_despues,
				UNIQUE (
					desde_id ASC,
					hasta_id DESC
				)
			);


			-- Table: salidas_importadas
			CREATE TABLE salidas_importadas (
				id_viejo          INTEGER  NOT NULL,
				id_nuevo          INTEGER  REFERENCES salidas (salida_id) ON DELETE CASCADE
										   NOT NULL,
				fecha_importacion DATETIME DEFAULT (datetime() ),
				UNIQUE (
					id_viejo ASC,
					id_nuevo DESC
				)
			);


			-- Table: zonas
			CREATE TABLE zonas (
				zona_id INTEGER PRIMARY KEY AUTOINCREMENT
								NOT NULL,
				nombre  TEXT    NOT NULL,
				color   INTEGER
			);


			-- Index: salas_hashes
			CREATE UNIQUE INDEX salas_hashes ON hash_salas (
				"slug" ASC,
				"sala_id" ASC
			);


			-- Index: salas_zonas
			CREATE INDEX salas_zonas ON salas (
				zona_id ASC
			);


			-- Index: salidas_desde_hasta
			CREATE UNIQUE INDEX salidas_desde_hasta ON salidas (
				"desde_id" ASC,
				"hasta_id" DESC
			);


			COMMIT TRANSACTION;
		]])
	end -- if
	local init_config = {
		config = config,
		get_room = getRoom,
		show_help = OnHelp,
		show_up_down = true,
	}
	
	mapper.init(init_config)
	config.SCAN.depth = 5000
	config.DELAY.time = 0.9
	

	if var.oculto then
		mapper.hide()
	end -- if
	
	if IsConnected() and var.sala then
		mover(tonumber(var.sala))
		EnableTrigger("mirar", true)
		EnableTrigger("mirar_arbol", true)
	end -- sala
	
	OnPluginEnable()
end -- OnPluginInstall

function OnPluginSend(texto)
	if salidas and salidaValida(texto) then
		local salida = salidaValida(texto)

		if salidas[salida] == "c" then
			SendImmediate("abrir "..(enviar[salida] or salida))
		end -- if
		
		SendImmediate(enviar[salida] or salida)
		return false
	end -- salidaValida
	
	-- Comportamiento predefinido
	return true
end -- function

function OnPluginClose()
	db:close()
	OnPluginDisable()
end -- OnPluginRemove

function modo_rapido()
	require "var"
	
	if var.rapido then
		mushreader.say("Desactivando el modo rápido.")
		var.rapido = nil
	else
		mushreader.say("Activando el modo rápido")
		var.rapido = true
	end -- if
end -- if

function OnPluginEnable()
	if IsConnected() and not var.oculto then
		mapper.show()
		EnableTrigger("mirar", true)
		EnableTrigger("mirar_arbol", true)
	end -- if
	
	AcceleratorTo("ALT+s", "mostrar_salidas()", sendto.script)
	AcceleratorTo("ALT+SHIFT+s", "modo_rapido()", sendto.script)
end -- function

function OnPluginDisable()
	mapper.hide()
	
	Accelerator("ALT+s", "")
	Accelerator("ALT+SHIFT+s", "")
end -- function

function OnPluginDisconnect()
	EnableTrigger("mirar", false)
	EnableTrigger("mirar_arbol", false)
end -- function

function on_mirar(name, line, wildcards, style)
	require "rex"
	local regexp = rex.new("^([\\-*~|]*)(\\w+)([\\-*~|]*)$")
	local aviso_puertas

	data.nombre = wildcards.room_name
	data.salidas = wildcards.exits
	
	salidas = {}
	
	for _, salida in pairs(utils.split(wildcards.exits, ",")) do
		local sstart, send, matches = regexp:match(salida)
		local tipo = matches[1]
		local nombre = matches[2]
		
		nombre = salidaValida(nombre) or nombre
		
		if tipo == "|" then
			salidas[nombre] = "c"
			if not aviso_puertas then
				play_sound("puertas/puertas_aqui.ogg")
			end -- aviso_puertas
		elseif tipo == "*" then
			salidas[nombre] = "r"
		else
			salidas[nombre] = "a"
		end -- if
		
	end -- salidas

	if var.rapido then
		mushreader.stop()
		mostrar_salidas()
	end -- if
end -- on_mirar

function mostrar_salidas()
	if mushreader and salidas then
		local str = ""
		
		for k in pairs(salidas) do
			if str ~= "" then
				str = str..","
			end -- str
			str = str..(enviar[k] or k)
		end
		mushreader.say(str)
	end -- if
end -- function

local function mostrar_consulta(resultado)
	assert(resultado, "No hay ningún resultado.")
	assert(type(resultado) == "table", "No se pasaron los resultados de una tabla.")
	
	-- Este sería el caso típico, pares de clave/valor.
	if #resultado == 0 then
		for k, v in pairs(resultado) do
			if type(v) == "table" then
				mostrar_consulta(v)
			elseif type(v) == "string" then
				mapper.mapprint(string.format("%s: %s", k, utf8convert(v)))
			else
				mapper.mapprint(string.format("%s: %s", k, v))
			end -- if
			
		end -- if
	else
		for k, v in ipairs(resultado) do
			mapper.mapprint(string.format("Registro %i:", k))
			mostrar_consulta(v)
			print()
			print()
		end -- for
	end -- if
end -- function

function on_pedir(name,line,wildcards)
	local success, result = pcall(query,wildcards[1])

	if success then
		local count = 0
		
		if #result == 0 then
			mapper.mapprint("No hay registros para mostrar")
			return
		end -- #result

		if #result == 1 then
			mapper.mapprint("Registro único:")
			print()
			result = result[1]
		end -- if

		mostrar_consulta(result)
	else
		mapper.maperror(result)
	end -- if
end -- on_pedir

function on_ver()
	if not current.room then
		mapper.maperror("No hay ninguna sala reconocida")
		return
	end -- if
	
	local sala = getRoom(current.room)
	
	mapper.mapprint([[
		Nombre: ${name}
		ID: ${id}
		
		Salidas:
	]] % sala)
	
	
	for k, v in pairs(sala.exits) do
		mapper.mapprint("			${salida}: ${destino} (${id})" % {
			salida = salidas_localizadas[k] or k,
			destino = getRoom(v).name,
			id = getRoom(v).id
		})
	end -- exits
	
	mapper.mapprint("		Fin")
end -- function

function on_importar()
	local archivo = utils.filepicker("Cargar mapa", nil, nil,
					{["*"] = "Todos los archivos",
					mdb = "Base de datos de Access"})

	if not archivo then
		return
	end -- if
	
	require("luacom")
	local exito, resultado
	
	-- Primero que nada tenemos que abrir la base de datos que contiene el mapa de zmud
	local zmud_db = luacom.CreateObject("ADODB.Connection")
	zmud_db:Open(string.format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s", archivo))
	
	assert(zmud_db.State == 1, "No se abrió la base de datos.")
	
	-- Esta función lee las salas desde la base de datos y no hace nada mas.
	local leer_salas = coroutine.create(function(access_db)
		local rs = access_db:Execute("select count(*) from ObjectTbl;")
		rs:MoveFirst()
		local result = rs.Fields:Item(0).Value
		rs:close()
		coroutine.yield(result)
		
		rs = access_db:Execute("select ObjId, Name from ObjectTbl;")
		rs:MoveFirst()
		
		while not rs.EOF do
			coroutine.yield({
				ObjId = tonumber(rs.Fields:Item("ObjId").Value),
				Name = rs.Fields:Item("Name").Value
			})
			
			rs:MoveNext()
		end -- EOF
		
		rs:Close()
	end) -- database loader

	-- Esta hace lo que la anterior, pero con las salidas
	local leer_salidas = coroutine.create(function(access_db)
		local rs = access_db:Execute("select count(*) from ExitTbl;")
		
		rs:MoveFirst()
		local result = rs.Fields:Item(0).Value
		rs:close()
		coroutine.yield(result)
		
		rs = access_db:Execute([[
			select ExitId, FromId, ToId, Name from ExitTbl
			where DirType+1 not in (select distinct DirId from DirTbl)
			union select ExitId, FromId, ToId, DirName from ExitTbl inner join DirTbl
			on ExitTbl.DirType = DirTbl.DirId-1
		]])

		rs:MoveFirst()
		while not rs.EOF do
			local row = {
				ExitId = tonumber(rs.Fields:item(0).Value),
				FromId = tonumber(rs.Fields:Item(1).Value),
				ToId = tonumber(rs.Fields:Item(2).Value),
				DirName = rs.Fields:Item(3).Value,
			}
			coroutine.yield(row)
			rs:MoveNext()
		end -- while
		
		rs:Close()
	end) -- function
	
	local importar_sala = coroutine.create(function(sala)
		-- Esta consulta preparada es la que va a insertar las salas.
		local insertar = db:prepare([[
			insert into salas (nombre)
			values(:nombre)
		]])
		
		-- Esta inserta la sala en la tabla de salas importadas.
		local agregar_importada = db:prepare([[
			insert into salas_importadas (id_viejo, id_nuevo)
			values(:id_viejo, :id_nuevo);
		]])
		
		-- Esta sentencia busca entre las salas importadas registradas en la base de datos para evitar volver a importar la misma sala.
		local pedir_importada = db:prepare([[
			select * from salas_importadas
			where id_viejo = :id_viejo
			limit 1;
		]])
		
		-- Si se pasan datos, importar la sala. En caso contrario, salir.
		while sala do
			-- Datos temporales varios
			pedir_importada:bind_values(sala.ObjId)
			
			if pedir_importada:step() ~= sqlite3.ROW then
				-- Importamos la sala
				local datos = {nombre = sala.Name}
				
				insertar:bind_names(datos)
				
				if insertar:step() == sqlite3.DONE then
					agregar_importada:bind_values(sala.ObjId, db:last_insert_rowid())
					
					agregar_importada:step()
					
					-- Reseteamos la consulta.
					agregar_importada:reset()
				else
					mapper.maperror(string.format("Error %i: %s", db:errcode(), db:errmsg()))
					break
				end -- result
				
				insertar:reset()
			end -- result
			
			pedir_importada:reset()
			
			
			sala = coroutine.yield()
		end -- sala
		
		insertar:finalize()
		agregar_importada:finalize()
		pedir_importada:finalize()
	end) -- function

	local importar_salidas = coroutine.create(function(salida)
		local ids_nuevos = {}
		
		for fila in db:nrows("select * from salas_importadas;") do
			ids_nuevos[fila.id_viejo] = fila.id_nuevo
		end -- for
		
		-- Estas sentencias sql preparadas son las que insertan la salida en la sala, además de registrarla en la tabla de salas importadas.
		local insertar_salida = db:prepare([[
			insert into salidas (desde_id, hasta_id, nombre)
			values(:desde_id, :hasta_id, :nombre)
		]])
		
		local insertar_importada = db:prepare([[
			insert into salidas_importadas (id_viejo, id_nuevo)
			values(:id_viejo, :id_nuevo)
		]])
		
		local pedir_importada = db:prepare([[
			select * from salidas_importadas
			where id_viejo = :id_viejo
			limit 1;
		]])
		
		local pedir_existe = db:prepare([[
			select * from salidas
			where desde_id = :desde_id and hasta_id = :hasta_id
			limit 1;
		]])
		
		local actualiza_salida = db:prepare([[
			update salidas
			set nombre = :nombre
			where salida_id = :id;
		]])
		
		while salida do
			-- Primero buscamos si la salida ya está importada
			pedir_importada:bind_values(salida.ExitId)
			
			if pedir_importada:step() ~= sqlite3.ROW then
				-- No existe, por tanto hay que importarla
				local datos = {
					desde = ids_nuevos[salida.FromId],
					hasta = ids_nuevos[salida.ToId],
					nombre = mapa_salidas[salida.DirName] or salida.DirName
				}
				
				-- Primero nos aseguramos de que la salida no esté importada ya en la base de datos
				pedir_existe:bind_values(datos.desde, datos.hasta)
				
				if pedir_existe:step() == sqlite3.ROW then
					-- Actualizamos
					actualiza_salida:bind_values(datos.nombre, pedir_existe:get_value(0))
					actualiza_salida:step()
					actualiza_salida:reset()
				else
					-- insertamos
					insertar_salida:bind_values(datos.desde, datos.hasta, datos.nombre)
					
					if insertar_salida:step() == sqlite3.DONE then
						insertar_importada:bind_values(salida.ExitId, db:last_insert_rowid())
						insertar_importada:step()
						insertar_importada:reset()
					end -- if
					
					insertar_salida:reset()
				end -- if
				
				pedir_existe:reset()
			end -- if
			
			pedir_importada:reset()
			
			salida = coroutine.yield()
		end -- salida
		
		-- Liberamos recursos
		pedir_importada:finalize()
		pedir_existe:finalize()
		insertar_salida:finalize()
		insertar_importada:finalize()
	end) -- function
	
	-- Ahora el proceso real, en el que vamos a usar las corrutinas antes creadas.
	exito, resultado = coroutine.resume(leer_salas, zmud_db)
	local cuenta_salas = resultado
	exito, resultado = coroutine.resume(leer_salidas, zmud_db)
	local cuenta_salidas = resultado
	mapper.mapprint(string.format("Se han encontrado %i salas y %i conexiones en la base de datos.", cuenta_salas, cuenta_salidas))
	
	-- Un contador para evitar todo el trabajo de un tirón y no colgar mushclient
	local maxpasos, pasos = 300, 0

	-- Lo primero es empezar una transacción
	db:exec("begin transaction;")
	
	-- primero importamos las salas
	while coroutine.status(leer_salas) ~= "dead" do
		exito, resultado = coroutine.resume(leer_salas)

		local sala = resultado

		exito, resultado = coroutine.resume(importar_sala, sala)
		
		if not exito then
			mapper.maperror(string.format("Error: %s", resultado))
			break
		end -- if
	end -- resultado
	
	
	while coroutine.status(leer_salidas) ~= "dead" do
		exito, resultado = coroutine.resume(leer_salidas)

		local salida = resultado

		exito, resultado = coroutine.resume(importar_salidas, salida)

		if not exito then
			mapper.maperror(string.format("Error: %s", resultado))
			break
		end -- if
		
	end -- status de leer_salidas
	
	local salas_actual = query("select count(*) as cuenta from salas")[1].cuenta
	local salidas_actual = query("select count(*) as cuenta from salidas")[1].cuenta
	
	mapper.mapprint(string.format([[
		En la base de datos original se encontraron %i salas y se importaron %i salas correctamente.
		Se encontraron además %i salidas, de las cuales %i se importaron correctamente.
	]], cuenta_salas, salas_actual, cuenta_salidas, salidas_actual))
	
	db:exec("commit;")
	zmud_db:Close()
	zmud_db = nil
	
	mapper.mapprint("La importación se realizó correctamente.")
	rooms = {}
end -- function

function on_buscar(name, line, wildcards)
	if not data.nombre then
		mapper.maperror "No hay datos con qué buscar."
		return
	end -- if
	
	local ids = {}
	
	for k, v in pairs(findRoomsWithNameContaining(data.nombre)) do
		table.insert(ids, v.sala_id)
	end -- findRoomByName 1
	
	local sala = elegir_sala(ids)
	
	if sala then
		mover(sala)
		on_ver()
	end -- selected
end -- function

function on_ir(name, line, wildcards)
	-- Si no hay una sala reconocida, salimos
	if not current.room then
		mapper.maperror("No tengo idea de donde estás.")
		return
	end -- if
	
	-- Un contador para prevenir cuelgues
	local salas = findRoomsWithNameContaining(wildcards[1])
	local counter = 0

	-- Esta es la función que usamos para buscar las salas
	local function prueba(x)
		if #salas == 0 then
			return false, true
		end -- if
		
		for k, v in pairs(salas) do
			if x == tonumber(v.sala_id) then
				counter = counter + 1

				if counter == #salas then
					-- Si ya encontramos todas, tenemos que devolver un segundo true para que no se continúe la búsqueda
					return true, true
				end -- if

				-- La sala es válida
				return true, false
			end -- if
		end -- salas

		-- Claro está, no encontramos nada
		return false, false
	end -- prueba

	mapper.find(prueba, false, 20, true)
end -- on_ir

function on_limpiar(name, line, wildcards)
	if not current.room then
		mapper.mapprint("No hay ninguna sala.")
	else
		mapper.mapprint("Olvidando la sala actual...")
		current = {}
	end -- if
end -- function

function on_mostrar()
	if not var.oculto then
		mapper.mapprint("El mapa ya se muestra.")
		return
	end -- if
	
	var.oculto = false
	mapper.show()
	mapper.mapprint("Se mostró el mapa.")
end -- function

function on_ocultar()
	if var.oculto then
		mapper.mapprint("El mapa ya est[a oculto.")
		return
	end -- var.oculto
	
	var.oculto = true
	mapper.hide()
	mapper.mapprint("Se ocultó el mapa")
end -- function

function OnHelp ()
	mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
end

function on_stop()
	mapper.cancel_speedwalk()
end -- on_stop

function on_editar(name,line,wc)
	if not var.editar then
		mapper.mapprint("Activando el modo de edición del mapa.")
		var.editar = true
	else
		mapper.mapprint("Modo de edición desactivado.")
		var.editar = nil
	end -- if
end -- function

function on_posicionar(n,l,wc)
	mapper.mapprint(string.format("Estableciendo la sala %i como la sala actual.", wc.id))
	mover(tonumber(wc.id))
end -- function

function on_conectar(name,line,wildcards)
	local desde = getRoom(current.room)
	local hasta = getRoom(tonumber(wildcards.id))
	
	if not desde then
		mapper.maperror("No hay ninguna sala reconocida.")
		return
	end -- if
	
	if not hasta then
		mapper.maperror("La sala con la que se quiere conectar no existe.")
		return
	end -- if
	
	local conectar = utils.msgbox(string.format("Se va a conectar con la sala %s. Proseder?", hasta.name), "Editar mapa", "yesno")
	
	if conectar == "yes" then
		desde.exits[mapa_salidas[wildcards.hacia] or wildcards.hacia] = hasta.id
		hasta.exits[mapa_salidas[wildcards.desde] or wildcards.desde] = desde.id
		db:exec("begin transaction;")
		guardar_sala(desde)
		guardar_sala(hasta)
		db:exec("commit transaction;")
		rooms[desde.id] = nil
		rooms[hasta.id] = nil
		getRoom(desde.id)
		getRoom(hasta.id)
		mapper.draw(current.room)
	end -- if
end -- on_conectar

function on_cambiar(name,line,wc)
	if not current.room then
		mapper.maperror("No hay ninguna sala reconocida.")
		return
	end -- if
	
	if not getRoom(tonumber(wc.id)) then
		mapper.maperror(string.format("La sala con el Id %s no existe.", wc.id))
		return
	end -- if
	
	local q = query([[
		select * from salidas
		where desde_id = :desde and hasta_id = :hasta
		limit 1;
	]], {
		desde = current.room,
		hasta = tonumber(wc.id)
	})[1]
	
	-- No vamos a usar la función query para todo, así que creamos una instrucción preparada primero
	local actualizar = db:prepare([[
		update salidas
		set nombre = :nombre
		where salida_id = :id;
	]])
	
	-- Empezamos una transacción
	db:exec("begin transaction;")
	
	actualizar:bind_values(mapa_salidas[wc.hacia] or wc.hacia, q.salida_id)
	
	if actualizar:step() == sqlite3.DONE then
		mapper.mapprint(string.format("Se cambió la salida de %s a %s.", salidas_localizadas[q.nombre] or q.nombre, salidas_localizadas[wc.hacia] or wc.hacia))
	end -- if
	
	-- Liberamos
	actualizar:finalize()
	db:exec("commit transaction;")
	
	-- volvemos a dibujar la sala
	rooms[current.room] = nil
	mapper.draw(current.room)
end -- on_cambiar

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="mapa ayuda"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[


]]>
</script> 

</muclient>
