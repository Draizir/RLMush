<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient [
  <!ENTITY prefijo "\$" >
  ]>
<!-- Saved on domingo, julio 08, 2018, 2:55 a. m. -->
<!-- MuClient version 5.05 -->

<!-- Plugin "rl_fichas" generated by Plugin Wizard -->

<muclient>
<plugin
   name="rl_fichas"
   author="Francisco R. Del Roio"
   id="f7823bfe980222e6736c9b69"
   language="Lua"
   purpose="Administra perfiles de clase y raza para personajes de reinos de leyenda."
   date_written="2018-07-08 02:50:38"
   requires="4.94"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[
	Este plugin se encarga de gestionar todo lo relativo a los alias del cliente para personajes, clases, razas, escuelas y esferas.
]]>
</description>

</plugin>

<aliases>
  <alias
   enabled="y"
   match="^&prefijo;depinfo$"
   regexp="y"
   script="on_depinfo">
  </alias>
  <alias
   enabled="y"
   match="^&prefijo;test$"
   regexp="y"
   script="on_test">
  </alias>
  <alias
   script="on_cinit"
   match="^&prefijo;cinit$"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   script="on_sinit"
   match="^&prefijo;sinit$"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Get our standard constants -->

<!-- <include name="constants.lua"/> -->




<!--  Script  -->
<script>
<![CDATA[
require "rl_stuff"
require "var"

-- Macros a comandos predefinidos:
local macros_predef = {
	["ALT+q"] = "c1",
	["ALT+w"] = "c2",
	["ALT+e"] = "c3",
	["ALT+r"] = "c4",
	["ALT+SHIFT+q"] = "c5",
	["ALT+SHIFT+w"] = "c6",
	["ALT+SHIFT+e"] = "c7",
	["ALT+SHIFT+r"] = "c8",
	["ALT+a"] = "s1",
	["ALT+s"] = "s2",
	["ALT+d"] = "s3",
	["ALT+f"] = "s4",
	["ALT+SHIFT+a"] = "s5",
	["ALT+SHIFT+s"] = "s6",
	["ALT+SHIFT+d"] = "s7",
	["ALT+SHIFT+f"] = "s8",
	["ALT+b"] = "buscar",
	["ALT+z"] = "estado -i todos",
	["ALT+x"] = "perder todo",
	["ALT+c"] = "estado -i x",
	["ALT+v"] = "parar",
	["ALT+i"] = "norte",
	["ALT+SHIFT+i"] = "mv norte",
	["ALT+k"] = "sur",
	["ALT+SHIFT+k"] = "mv sur",
	["ALT+j"] = "oeste",
	["ALT+SHIFT+j"] = "mv oeste",
	["ALT+l"] = "este",
	["ALT+SHIFT+l"] = "mv este",
	["ALT+u"] = "no",
	["ALT+SHIFT+u"] = "mv no",
	["ALT+o"] = "ne",
	["ALT+SHIFT+o"] = "mv ne",
	["ALT+m"] = "so",
	["ALT+SHIFT+m"] = "mv so",
	["ALT+."] = "se",
	["ALT+SHIFT+."] = "mv se",
	["ALT+,"] = "ojear",
	["ALT+`"] = "abajo",
	["ALT+SHIFT+,"] = "mvc",
	["ALT+SHIFT+`"] = "mv abajo",
	["ALT+p"] = "arriba",
	["ALT+SHIFT+p"] = "mv arriba",
}

-- Niveles de acceso
local niveles_acceso = {
	menor = 1,
	neutral = 2,
	mayor = 3,
}

-- Estos datos se recargan cada vez que se recibe un mensaje GMCP 'Char.Ficha'
local personaje, clase, especializacion, esferas, escuelas, oficio, raza

local function ruta_valida(nombre, actual, raiz)
	local ruta
	
	-- Validamos primero
	assert(nombre, "No se proporcionó 'nombre'.")
	assert(type(nombre) == "string", "'nombre' no es una cadena válida.")
	assert(nombre ~= "", "'nombre' no puede ser una cadena vacía.")

	-- Restringimos la capacidad de búsqueda de archivos
	assert(not nombre:find("..", 1, true), "No se admite la secuencia '..' en 'nombre'.")

	if not raiz then
		raiz = GetInfo(66).."rlmud"
	end -- if
	
	if not actual then
		actual = raiz
	else
		actual = raiz.."/"..actual
	end -- if

	-- Rutas absolutas desde la raíz
	if nombre:sub(1, 1) == "~" then
		ruta = string.format("%s%s", raiz, nombre:sub(2, -1))
	else
		ruta = string.format("%s/%s", actual, nombre)
	end -- if
	
	return ruta
end -- function

local function cargar_archivo(nombre, actual, raiz)
	-- Falla si se intenta abrir una carpeta o un archivo no existente.
	local archivo, mensaje = io.open(ruta_valida(nombre, actual, raiz), "r")
	if not archivo then
		return nil, mensaje
	end -- if

	-- Llegados a este punto, tenemos un archivo abierto listo para leer
	local cadena = archivo:read("*a")

	-- Ya no necesitamos el archivo, así que lo cerramos
	archivo:close()

	return cadena
end -- function

local function cargar_xml(nombre, actual, raiz)
	local cadena, mensaje = cargar_archivo(nombre, actual, raiz)
	if not cadena then
		return nil, mensaje
	end -- if

	local xml, mensaje, linea = utils.xmlread(cadena)
	if not xml then
		error(string.format("%s %s: %s", nombre, linea, mensaje))
	end -- if
	
	return xml, nombre
end -- function

local function procesar_clase(nodo)
	if not nodo.attributes.nombre then
		return nil, "No se definió el nombre de la clase.", nodo.line
	end -- if
	
	local clase = {
		nombre = nodo.attributes.nombre,
		nombre_completo = nodo.attributes.nombre_completo,
		magia = {},
		archivos = {},
	}

	for i, node in ipairs(nodo.nodes) do
		-- Primero lo mas sencillo de cargar, la lista de archivos
		-- Solo se aceptan archivos enlistados en un nodo vacío del estilo <archivo ruta="ruta" />
		if node.name == "archivo" then
			if not node.attributes.ruta or node.ruta == "" then
				return nil, "No se definió la ruta del archivo a cargar.", node.line
			end -- if

			table.insert(clase.archivos, node.attributes.ruta)
		elseif node.name == "magia" then
			if node.nodes then
				for j, subnode in ipairs(node.nodes) do
					if not subnode.attributes.nombre then
						return nil, "No se definió el nombre del elemento.", node.line
					end -- if
					
					if not subnode.attributes.acceso then
						return nil, "No se definió el acceso del elemento.", subnode.line
					end -- if
					
					if not niveles_acceso[subnode.attributes.acceso] then
						return nil, string.format("%s no es un acceso válido.", subnode.attributes.acceso), subnode.line
					end -- if
					local magia = {
						nombre = subnode.attributes.nombre,
						
						-- Es mucho mas sencillo si tratamos el acceso en una manera numérica
						acceso = niveles_acceso[subnode.attributes .acceso],
						
						tipo = subnode.name
					}
					
					if subnode.name == "escuela" or subnode.name == "esfera" then
						table.insert(clase.magia, magia)
					else
						return nil, "El elemento no es válido.", subnode.line
					end -- if
				end -- for
			end -- if
		elseif node.name == "mushclient" then
			-- Parseamos el contenido XML de este nodo y lo reconvertimos a una string
			local cadena_mushclient = ""
			
			if node.nodes then
				for k, subnode in ipairs(node.nodes) do
					cadena_mushclient = cadena_mushclient..denuevo_xml(subnode, "  ") .. "\n"
				end -- for
			end -- if
			
			clase.mushclient = cadena_mushclient
		end -- if
	end -- for
	
	return clase
end -- function

local function cargar_personaje(nombre)
	assert(nombre, "No se proporcionó el parámetro 'nombre'.")
	assert(type(nombre) == "string", "El parámetro 'nombre' no es una cadena válida.")
	assert(nombre ~= "", "El parámetro 'nombre' no puede ser una cadena vacía.")
	
	local ruta_personaje = string.format("personajes/%s.xml", nombre:lower())
	
	local cadena, mensaje = cargar_archivo(ruta_personaje)
	
	-- Si no existe el perfil, se generará uno desde cero a partir de una plantilla
	if not cadena then
		local archivo = assert(io.open(ruta_valida(ruta_personaje), "w"))
		
		-- Indentación removida, contenido plano
		local escribir = string.format([[
<?xml version="1.0" encoding="iso8859-15"?>
<!DOCTYPE personaje>

<personaje nombre="%s" nombre_completo="%s">
    <!-- Agregue archivos en esta sección
         Para listar un archivo a cargar se usa la forma siguiente:

         <archivo ruta="<rutarelativa>" />
    -->

    <!-- Triggers y alias en bruto de MUSHclient -->
    <mushclient>
        <!-- Pegar dentro de este elemento los alias y triggers de MUSHclient -->

    </mushclient>
</personaje>]], nombre, nombre)
		
		archivo:write(escribir)
		archivo:close()
		return cargar_personaje(nombre)
	end -- if
	
	local xml, ruta = cargar_xml(string.format("personajes/%s.xml", nombre:lower()))
	
	for k, nodo in ipairs(xml.nodes) do
		if nodo.name == "personaje" then
			xml = nodo
			break
		end -- if
	end -- for
	
	assert(xml.name == "personaje", "La configuración de personaje no es válida.")
	
	local pj, mensaje, linea = procesar_clase(xml)
	
	if not pj then
		error(string.format("%s %s: %s", ruta, linea, mensaje))
	end -- if
	
	-- Quitamos la información de esferas/escuelas del perfil
	pj.magia = nil

	return pj, mensaje, linea
end -- cargar_personaje

local function cargar_clase(nombre)
	assert(nombre, "No se proporcionó el parámetro 'nombre'.")
	assert(type(nombre) == "string", "El parámetro 'nombre' no es una cadena válida.")
	assert(nombre ~= "", "El parámetro 'nombre' no puede ser una cadena vacía.")
	
	-- Cargamos el archivo
	local xml, ruta = cargar_xml(string.format("clases/%s/config.xml", nombre:lower()))
	
	for id, node in pairs(xml.nodes) do
		if node.name == "clase" then
			xml = node
			
			-- Terminamos con el archivo
			break
		end -- if
	end -- for
	
	assert(xml.name == "clase", string.format("El archivo \"%s\" no contiene una configuración de clase válida.", ruta))
	assert(xml.attributes.nombre == nombre, string.format("%s %s: El nombre de la clase no coinside.", ruta, xml.line))
	
	-- Generamos una estructura de clase plana
	local clase, mensaje, linea = procesar_clase(xml)
	
	-- Reporte de error estándar
	if not clase then
		error(string.format("%s %s: %s", ruta, linea, mensaje))
	end -- if
	
	return clase
end -- cargar_clase

local function cargar_especializacion(nombre)
	assert(nombre, "No se proporcionó el parámetro 'nombre'.")
	assert(type(nombre) == "string", "El parámetro 'nombre' no es una cadena válida.")
	assert(nombre ~= "", "El parámetro 'nombre' no puede ser una cadena vacía.")
	
	-- Cargamos el archivo
	local xml, ruta = cargar_xml(string.format("clases/%s/%s.xml", var.clase, nombre:lower()))
	
	for id, node in pairs(xml.nodes) do
		if node.name == "clase" then
			xml = node
			
			-- Terminamos con el archivo
			break
		end -- if
	end -- for
	
	assert(xml.name == "clase", string.format("El archivo \"%s\" no contiene una configuración de clase válida.", ruta))
	assert(xml.attributes.nombre == nombre, string.format("%s %s: El nombre de la clase no coinside.", ruta, xml.line))
	
	-- Generamos una estructura de clase plana
	local clase, mensaje, linea = procesar_clase(xml)
	
	-- Reporte de error estándar
	if not clase then
		error(string.format("%s %s: %s", ruta, linea, mensaje))
	end -- if
	
	return clase
end -- function

local function cargar_magia(elem)
	local xml, mensaje, obj
	
	-- Aquí hay que ser selectivo
	if elem.tipo == "escuela" then
		xml, mensaje = cargar_xml(string.format("escuelas/%s.xml", elem.nombre))
	else
		xml, mensaje = cargar_xml(string.format("esferas/%s.xml", elem.nombre))
	end -- if
	
	if not xml then
		-- Terminar silenciosamente
		return
	end -- if
	
	for k, nodo in ipairs(xml.nodes) do	
		
		if nodo.name == elem.tipo then
			xml = nodo
			break
		end -- if
	end -- for
	
	assert(xml.name == elem.tipo, string.format("El archivo \"%s\" no contiene una configuración válida.", mensaje))
	assert(xml.attributes.nombre == elem.nombre, string.format("%s %s: Los nombres no coinsiden.", mensaje, xml.line))
	
	obj = {
		nombre = xml.attributes.nombre,
		nombre_completo = xml.attributes.nombre_completo,
		archivos = {},
	}
	
	for k, nodo in ipairs(xml.nodes) do
		if nodo.name == "archivo" then
			if not nodo.attributes.ruta or nodo.attributes.ruta == "" then
				error(string.format("%s %s: No se especificó una ruta de archivo válida.", ruta, nodo.line))
			end -- if
			
			-- Forzamos a que se especifique el nivel de acceso de cada archivo
			if not nodo.attributes.acceso then
				error(string.format("%s %s: No se especificó el nivel de aceso.", ruta, nodo.line))
			end -- if
			
			if not niveles_acceso[nodo.attributes.acceso] then
				error(string.format("%s %s: El nivel de acceso \"%s\" no es válido.", ruta, nodo.line, nodo.attributes.acceso))
			end -- if
			
			table.insert(obj.archivos, {
				ruta = nodo.attributes.ruta,
				acceso = niveles_acceso[nodo.attributes.acceso],
			})
		elseif nodo.name == "mushclient" then
			local mushclient_cadena = ""
			
			if nodo.nodes then
				for k, subnodo in ipairs(nodo.nodes) do
					mushclient_cadena = mushclient_cadena .. denuevo_xml(subnodo) .. "\n\n"
				end -- for
			end -- if
			
			obj.mushclient = mushclient_cadena
		end -- if
	end -- for
	
	return obj, elem.nombre
end -- function

function on_depinfo()
	require "tprint"
	
	if personaje then
		tprint(personaje)
	end -- if
	
	if clase then
		tprint(clase)
	end -- if
	
	if especializacion then
		tprint(especializacion)
	end -- if
	
	if esferas then
		tprint(esferas)
	end -- if
end -- function

function on_test()
	print(ruta_valida("fran.xml", "personajes"))
end -- function

function OnPluginListChanged()
	RLStuffListChanged()
end -- function

function OnGMCPInit()
	require "var"
	
	var.clase = nil
	var.oficio = nil
	var.raza = nil
	var.nombre = nil
	var.nombre_completo = nil
	personaje, clase, especializacion, esferas, escuelas, oficio, raza = nil
end -- function

function OnPluginDisconnect()
	require "var"
	
	OnGMCPInit()
	personaje, clase, especializacion = nil, nil, nil
end -- function

local function on_personaje(nombre, nombre_completo)
	var.nombre = nombre
	var.nombre_completo = nombre_completo
	
	local personaje_cargado = cargar_personaje(var.nombre:lower())

	personaje = personaje_cargado
end -- function

local function on_clase(nombre)
	var.clase = nombre
	
	local result, clase_cargada = pcall(cargar_clase, var.clase)
	
	if not result then
		return
	end -- if
	
	clase = clase_cargada
	
	for k, elem in ipairs(clase_cargada.magia) do
		local magia, nombre = cargar_magia(elem)
		if magia then
			if elem.tipo == "esfera" then
				if not esferas then
					esferas = {}
				end -- if
				
				esferas[elem.nombre] = magia
			else
				if not escuelas then
					escuelas = {}
				end -- if
				
				escuelas[elem.nombre] = magia
			end -- if
		end -- if
	end -- for
end -- function

local function on_especializacion(nombre)
	var.especializacion = nombre
	
	local result, esp_cargada = pcall(cargar_especializacion, nombre)
	
	if not result then
		return
	end -- if
	
	especializacion = esp_cargada
	
	for k, elem in ipairs(esp_cargada.magia) do
		local magia, nombre = cargar_magia(elem)
		if magia then
			if elem.tipo == "esfera" then
				if not esferas then
					esferas = {}
				end -- if
				
				esferas[elem.nombre] = magia
			else
				if not escuelas then
					escuelas = {}
				end -- if
				
				escuelas[elem.nombre] = magia
			end -- if
		end -- if
	end -- for
end -- function

local function on_oficio(nombre)
	var.oficio = nombre
end -- function

function on_raza(nombre)
	var.raza = nombre
end -- function

local function recargar_todo()
	-- Necesitamos llevar la cuenta para evitar que un archivo se cargue dos o mas veces
	local archivos_cargados = {}
	DeleteTemporaryAliases()
	DeleteTemporaryTriggers()

	local function ejecutar_archivo(archivo, carpeta)
		local ruta_archivo = ruta_valida(archivo, carpeta)
		if archivos_cargados[ruta_archivo] == nil then
			local cadena, mensaje = cargar_archivo(archivo, carpeta)
			
			if cadena then
				if ImportXML(cadena) >= 0 then
					archivos_cargados[ruta_archivo] = true
				else
					archivos_cargados[ruta_archivo] = false
					print("Error en la importación del archivo \""..archivo.."\".")
				end -- if
			else
				archivos_cargados[ruta_archivo] = false
				print(string.format("Error: %s", mensaje))
			end -- if
		end -- if
	end -- function
	
	-- Cargamos un personaje
	if personaje then
		-- Lo lógico es cargar los archivos en primer lugar
		for k, archivo in ipairs(personaje.archivos) do
			ejecutar_archivo(archivo, "personajes")
		end -- for
		ImportXML(personaje.mushclient)
	end -- if
	
	-- Cargamos la clase
	if clase then
		for k, archivo in ipairs(clase.archivos) do
			ejecutar_archivo(archivo)
		end -- for
		ImportXML(clase.mushclient)
		
		-- Escuelas y esferas
		for k, elem in ipairs(clase.magia) do
			if elem.tipo == "esfera" and esferas[elem.nombre] then
				magia = esferas[elem.nombre]
				
				for j, archivo in ipairs(magia.archivos) do
					if elem.acceso >= archivo.acceso then
						ejecutar_archivo(archivo.ruta, "esferas")
					end -- if
				end -- for
				
				ImportXML(magia.mushclient)
			elseif elem.tipo == "escuela" and escuelas[elem.nombre] then
				magia = escuelas[elem.nombre]
				
				for j, archivo in ipairs(magia.archivos) do
					if elem.acceso >= archivo.acceso then
						ejecutar_archivo(archivo.ruta, "escuelas")
					end -- if
				end -- for
				
				ImportXML(magia.mushclient)
			end -- if
		end -- for
	end -- if
	
	-- Y la especialización
	if especializacion then
		for k, archivo in ipairs(especializacion.archivos) do
			ejecutar_archivo(archivo)
		end -- for
		ImportXML(especializacion.mushclient)
		
		
		-- Escuelas y esferas
		for k, elem in ipairs(especializacion.magia) do
			if elem.tipo == "esfera" and esferas[elem.nombre] then
				magia = esferas[elem.nombre]
				
				for j, archivo in ipairs(magia.archivos) do
					if elem.acceso >= archivo.acceso then
						ejecutar_archivo(archivo.ruta, "esferas")
					end -- if
				end -- for
				
				ImportXML(magia.mushclient)
			elseif elem.tipo == "escuela" and escuelas[elem.nombre] then
				magia = escuelas[elem.nombre]
				
				for j, archivo in ipairs(magia.archivos) do
					if elem.acceso >= archivo.acceso then
						ejecutar_archivo(archivo.ruta, "escuelas")
					end -- if
				end -- for
				
				ImportXML(magia.mushclient)
			end -- if
		end -- for
	end -- if
	
	-- Raza y oficio también
	if raza then
		ImportXML(raza.mushclient)
	end -- if
end -- function

function OnGMCP(mensaje)
	if mensaje ~= "Char.Ficha" then return end
	
	-- Parseamos los datos mediante json
	local ficha = PedirGMCP("Char.Ficha")
	
	if ficha.nombre then
		on_personaje(ficha.nombre, ficha.nombre_completo)
	end -- if
	
	if ficha.clase then
		on_clase(ficha.clase)
	end -- if
	
	if ficha.especializacion then
		on_especializacion(ficha.especializacion)
	end -- if
	
	if ficha.oficio then
		on_oficio(ficha.oficio)
	end -- if
	
	if ficha.raza then
		on_raza(ficha.raza)
	end -- if
	
	recargar_todo()
end -- function

function OnPluginInstall()
	OnPluginEnable()

	if IsConnected() then
		OnGMCP("Char.Ficha")
	end -- if
end -- function

function OnPluginClose()
	DeleteTemporaryAliases()
	OnPluginDisable()
end -- function

function OnPluginEnable()
	for k, v in pairs(macros_predef) do
		Accelerator(k, v)
	end
end -- function

function OnPluginDisable()
	for k, v in pairs(macros_predef) do
		Accelerator(k, "")
	end -- for
end -- function

function on_cinit(name,line,wc)
	if not var.clase then
		print("No estás conectado con ningún personaje.")
		return
	end -- if
	
	if clase then
		print("Ya existe esa clase.")
		return
	end -- if
	
	print(string.format("Generando el archivo para la clase %s ...", var.clase))
	local ruta_clase = ruta_valida("clases/"..var.clase)
	
	local iter, dir_obj = lfs.dir(ruta_clase)
	
	if not pcall(iter) then
		lfs.mkdir(ruta_clase)
	end -- if
	
	local archivo, mensaje = io.open(ruta_clase.."/config.xml", "w")
	if not archivo then
		print(mensaje)
		return
	end -- if
	
	archivo:write(string.format([[
<?xml version="1.0" encoding="iso8859-15"?>
<!DOCTYPE clase>

<clase nombre="%s">
    <!-- Archivo de clase autogenerado -->

    <!-- Ver el README para obtener información sobre como usar este archivo -->

    <magia>
        <!-- Lista de esferas/escuelas -->

    </magia>

    <mushclient>
        <!-- Alias y triggers en bruto de mushclient -->

    </mushclient>
</clase>
]], var.clase))
	archivo:close()
	
	-- Forzamos la carga de la clase
	on_clase(var.clase)
	
	-- Si es llamado desde el alias se recarga todo
	if wc then
		recargar_todo()
	end -- if
end -- function

function on_sinit()
	if not IsConnected() or not var.especializacion then
		print("No estás conectado.")
		return
	end -- if

	if especializacion then
		print("Ya hay una configuración para esta especialización.")
		return
	end -- if

	-- Si no hay configuración para la clase, se genera una
	if not clase then
		on_cinit()
	end -- if
	
	local ruta_esp = ruta_valida("clases/"..clase.nombre.."/"..var.especializacion..".xml")

	print(string.format("Generando el archivo para la especialización %s ...", var.especializacion))

	local archivo, mensaje = io.open(ruta_esp, "w")
	
	if not archivo then
		print(string.format("Error: %s", mensaje))
		return
	end -- if

	-- Contenido del archivo, no indentado
	archivo:write(string.format([[
<?xml version="1.0" encoding="iso8859-15"?>
<!DOCTYPE clase>

<clase nombre="%s">
    <!-- Archivo de clase autogenerado -->

    <!-- Ver el README para obtener información sobre como usar este archivo -->

    <magia>
        <!-- Lista de esferas/escuelas -->

    </magia>

    <mushclient>
        <!-- Alias y triggers en bruto de mushclient -->

    </mushclient>
</clase>
]], var.especializacion))
	archivo:close()
	
	on_especializacion(var.especializacion)
	recargar_todo()
end -- function

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="rl_fichas:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
